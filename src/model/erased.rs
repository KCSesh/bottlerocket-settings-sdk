//! The Bottlerocket Settings SDK requires settings extension creators to implement
//! [`SettingsModel`] on their model structs to define how their settings behave.
//! Within the SDK itself, we need a way to store a list of these [`SettingsModel`] types in memory
//! so that we can process requests against them.
//!
//! This module contains traits which erase the underlying [`SettingsModel`] types, allowing the
//! SDK to refer to the [`SettingsModel`]s as a collection of trait objects.
use super::{error, BottlerocketSetting, BottlerocketSettingError, GenerateResult, SettingsModel};
use snafu::ResultExt;
use std::any::Any;
use std::fmt::Debug;
use tracing::{debug, instrument};

/// A type-erased analogue to [`SettingsModel`], primarly intended to be used internally by the SDK.
///
/// This trait is currently designed to be implemented only by [`BottlerocketSetting`], which is
/// an empty struct generic over [`SettingsModel`]. This is useful because it allows the SDK to have
/// a collection of `Box<dyn TypeErasedModel>` which can use their underlying `SettingsModel`
/// implementation to respond to function calls.
///
/// Methods on this trait take a reference to `&self`, but this is only done to satisfy the
/// requirements to make this trait "object-safe".
///
/// Type-erasure is done via serialization/deserialization of [`serde_json::Value`] types passed in
/// through the user interface.
/// Downcasting to user-defined model types is performed via deserialization by the implementor,
/// of this trait [`BottlerocketSetting`].
///
/// In cases where the values are being passed to a migrator, the values are deserialized and then
/// type-erased once again with [`std::any::Any`], which is much more efficient than repeatedly
/// erasing/downcasting via serialization.
pub trait TypeErasedModel: Debug {
    /// Returns the version of the model, e.g. "v1".
    fn get_version(&self) -> &'static str;

    /// Determines whether this setting can be set to the `target` value, given its current value.
    ///
    /// The returned value is what is ultimately set in the settings datastore. While this leaves
    /// room for the extension to modify the value that is stored, this should be done cautiously
    /// so as not to confuse users.
    fn set(
        &self,
        current: Option<serde_json::Value>,
        target: serde_json::Value,
    ) -> Result<serde_json::Value, BottlerocketSettingError>;

    /// Generates default values at system start.
    ///
    /// The settings system repeatedly invokes `generate` on all settings until they have
    /// completed. On each generation cycle, the settings extension is provided any values that it
    /// has previously generated, as well as all of the data that has thus far been generated by its
    /// dependencies.
    fn generate(
        &self,
        existing_partial: Option<serde_json::Value>,
        dependent_settings: Option<serde_json::Value>,
    ) -> Result<GenerateResult<serde_json::Value, serde_json::Value>, BottlerocketSettingError>;

    /// Validates this setting, allowing for cross-validation with other settings.
    ///
    /// Cross-validated settings are provided as a JSON Map, where the key is the extension name and
    /// the value is the value of that setting.
    fn validate(
        &self,
        value: serde_json::Value,
        validated_settings: Option<serde_json::Value>,
    ) -> Result<bool, BottlerocketSettingError>;

    /// Parses a JSON value into the underlying model type, then erases its type via the `Any` trait.
    ///
    /// This is useful for implementing efficient migrations.
    fn parse_erased(
        &self,
        value: serde_json::Value,
    ) -> Result<Box<dyn Any>, BottlerocketSettingError>;
}

/// A helper trait used to "upcast" supertraits over the [`TypeErasedModel`] trait.
///
/// This is required until Rust supports trait upcast coercion.
/// `<https://github.com/rust-lang/rust/issues/65991>`
pub trait AsTypeErasedModel {
    fn as_model(&self) -> &dyn TypeErasedModel;
}

impl<T: TypeErasedModel> AsTypeErasedModel for T {
    fn as_model(&self) -> &dyn TypeErasedModel {
        self
    }
}

impl<T: SettingsModel + 'static> TypeErasedModel for BottlerocketSetting<T> {
    fn get_version(&self) -> &'static str {
        T::get_version()
    }

    #[instrument(skip(self), err)]
    fn set(
        &self,
        current: Option<serde_json::Value>,
        target: serde_json::Value,
    ) -> Result<serde_json::Value, BottlerocketSettingError> {
        debug!(
            current_value = current.as_ref().map(|v| v.to_string()),
            target_value = target.to_string(),
            version = %T::get_version(),
            "Setting new value for setting."
        );
        let current = current
            .map(|v| {
                serde_json::from_value(v.clone()).context(error::DeserializeInputSnafu {
                    version: T::get_version(),
                    input: v,
                    input_type: "current-value",
                })
            })
            .transpose()?;

        let target =
            serde_json::from_value(target.clone()).context(error::DeserializeInputSnafu {
                version: T::get_version(),
                input: target,
                input_type: "target-value",
            })?;
        T::set(current, target)
            .map_err(Into::into)
            .context(error::SetSettingSnafu {
                version: T::get_version(),
            })
            .and_then(|retval| {
                serde_json::to_value(retval).context(error::SerializeResultSnafu {
                    version: T::get_version(),
                    operation: "set",
                })
            })
    }

    #[instrument(skip(self), err)]
    fn generate(
        &self,
        existing_partial: Option<serde_json::Value>,
        dependent_settings: Option<serde_json::Value>,
    ) -> Result<GenerateResult<serde_json::Value, serde_json::Value>, BottlerocketSettingError>
    {
        debug!(
            existing_partial = existing_partial.as_ref().map(|v| v.to_string()),
            dependent_settings = dependent_settings.as_ref().map(|v| v.to_string()),
            version = %T::get_version(),
            "Generating new value for setting."
        );

        let existing_partial = existing_partial
            .map(|v| {
                serde_json::from_value(v.clone()).context(error::DeserializeInputSnafu {
                    version: T::get_version(),
                    input: v,
                    input_type: "existing-partial",
                })
            })
            .transpose()?;
        T::generate(existing_partial, dependent_settings)
            .map_err(Into::into)
            .context(error::GenerateSettingSnafu {
                version: T::get_version(),
            })
            .and_then(|gr| {
                gr.serialize().context(error::SerializeResultSnafu {
                    version: T::get_version(),
                    operation: "generate",
                })
            })
    }

    #[instrument(skip(self), err)]
    fn validate(
        &self,
        value: serde_json::Value,
        validated_settings: Option<serde_json::Value>,
    ) -> Result<bool, BottlerocketSettingError> {
        debug!(
            %value,
            validated_settings = validated_settings.as_ref().map(|v| v.to_string()),
            version = %T::get_version(),
            "Validating value value for setting."
        );

        let value =
            serde_json::from_value(value.clone()).context(error::DeserializeInputSnafu {
                version: T::get_version(),
                input: value,
                input_type: "value",
            })?;
        T::validate(value, validated_settings)
            .map_err(Into::into)
            .context(error::ValidateSettingSnafu {
                version: T::get_version(),
            })
    }

    #[instrument(skip(self), err)]
    fn parse_erased(
        &self,
        value: serde_json::Value,
    ) -> Result<Box<dyn Any>, BottlerocketSettingError> {
        debug!(
            %value,
            version = %T::get_version(),
            "Parsing JSON value for setting."
        );

        serde_json::from_value::<T>(value)
            .context(error::ParseSettingSnafu {
                version: T::get_version(),
            })
            .map(|parsed| Box::new(parsed) as Box<dyn Any>)
    }
}
